to override super-class methods. Some languages support multiple inheritance, where
a class can inherit from more than one class, and other languages similarly support
mixins or traits. For example, a mixin called UnicodeConversionMixin might add a method
unicode_to_ascii() to both a FileReader and a WebPageScraper class. An abstract class
cannot be directly instantiated as an object. It is only used as a super-class. Other
classes are utility classes which contain only class variables and methods and are
not meant to be instantiated or subclassed. [45] Instead of providing a class concept,
in prototype-based programming, an object is linked to another object, called its
prototype or parent. In Self, an object may have multiple or no parents, [46] but
in the most popular prototype-based language, JavaScript, an object has exactly one
prototype link, up to the base object whose prototype is null. A prototype acts as
a model for new objects. For example, if you have an object fruit, you can make two
objects apple and orange that share traits of the fruit prototype. Prototype-based
languages also allow objects to have their own unique properties, so the apple object
might have an attribute sugar_content, while the orange or fruit objects do not. Some
languages, like Go, don't support inheritance. [47] Instead, they encourage "composition
over inheritance", where objects are built using smaller parts instead of parent-child
relationships. For example, instead of inheriting from class Person, the Employee
class could simply contain a Person object. This lets the Employee class control how
much of Person it exposes to other parts of the program. Delegation is another language
feature that can be used as an alternative to inheritance. Programmers have different
opinions on inheritance. Bjarne Stroustrup, author of C++, has stated that it is possible
to do OOP without inheritance. [48] Rob Pike has criticized inheritance for creating
complex hierarchies instead of simpler solutions. [49] People often think that if
one class inherits from another, it means the subclass "is a" more specific version
of the original class. This presumes the program semantics are that objects from the
subclass can always replace objects from the original class without problems. This
concept is known as behavioral subtyping, more specifically the Liskov substitution
principle. However, this is often not true, especially in programming languages that
allow mutable objects, objects that change after they are created. In fact, subtype
polymorphism as enforced by the type checker in OOP languages cannot guarantee behavioral
subtyping in most if not all contexts. For example, the circle-ellipse problem is
notoriously difficult to handle using OOP's concept of inheritance. Behavioral subtyping
is undecidable in general, so it cannot be easily implemented by a compiler. Because
of this, programmers must carefully design class hierarchies to avoid mistakes that
the programming language itself cannot catch. A method may be invoked via dynamic
dispatch such that the method is selected at runtime instead of compile time. If the
method choice depends on more than one type of object (such as other objects passed